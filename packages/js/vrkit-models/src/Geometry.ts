// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "Geometry.proto" (package "IRacingTools.Models", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message IRacingTools.Models.PositionI
 */
export interface PositionI {
    /**
     * @generated from protobuf field: int32 x = 1;
     */
    x: number;
    /**
     * @generated from protobuf field: int32 y = 2;
     */
    y: number;
}
/**
 * @generated from protobuf message IRacingTools.Models.PositionF
 */
export interface PositionF {
    /**
     * @generated from protobuf field: float x = 1;
     */
    x: number;
    /**
     * @generated from protobuf field: float y = 2;
     */
    y: number;
}
/**
 * @generated from protobuf message IRacingTools.Models.SizeI
 */
export interface SizeI {
    /**
     * @generated from protobuf field: uint32 width = 1;
     */
    width: number;
    /**
     * @generated from protobuf field: uint32 height = 2;
     */
    height: number;
}
/**
 * @generated from protobuf message IRacingTools.Models.SizeF
 */
export interface SizeF {
    /**
     * @generated from protobuf field: float width = 1;
     */
    width: number;
    /**
     * @generated from protobuf field: float height = 2;
     */
    height: number;
}
/**
 * @generated from protobuf message IRacingTools.Models.RectI
 */
export interface RectI {
    /**
     * @generated from protobuf field: IRacingTools.Models.SizeI size = 1;
     */
    size?: SizeI;
    /**
     * @generated from protobuf field: IRacingTools.Models.PositionI position = 2;
     */
    position?: PositionI;
}
/**
 * @generated from protobuf message IRacingTools.Models.RectF
 */
export interface RectF {
    /**
     * @generated from protobuf field: IRacingTools.Models.SizeF size = 1;
     */
    size?: SizeF;
    /**
     * @generated from protobuf field: IRacingTools.Models.PositionF position = 2;
     */
    position?: PositionF;
}
/**
 * @generated from protobuf message IRacingTools.Models.VRPose
 */
export interface VRPose {
    /**
     * @generated from protobuf field: float x = 1;
     */
    x: number;
    /**
     * @generated from protobuf field: float eyeY = 2;
     */
    eyeY: number;
    /**
     * @generated from protobuf field: float z = 3;
     */
    z: number;
}
/**
 * @generated from protobuf message IRacingTools.Models.VRLayout
 */
export interface VRLayout {
    /**
     * @generated from protobuf field: IRacingTools.Models.VRPose pose = 1;
     */
    pose?: VRPose;
    /**
     * @generated from protobuf field: IRacingTools.Models.SizeF size = 2;
     */
    size?: SizeF;
}
// @generated message type with reflection information, may provide speed optimized methods
class PositionI$Type extends MessageType<PositionI> {
    constructor() {
        super("IRacingTools.Models.PositionI", [
            { no: 1, name: "x", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "y", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<PositionI>): PositionI {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.x = 0;
        message.y = 0;
        if (value !== undefined)
            reflectionMergePartial<PositionI>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionI): PositionI {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 x */ 1:
                    message.x = reader.int32();
                    break;
                case /* int32 y */ 2:
                    message.y = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionI, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Varint).int32(message.x);
        /* int32 y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Varint).int32(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message IRacingTools.Models.PositionI
 */
export const PositionI = new PositionI$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionF$Type extends MessageType<PositionF> {
    constructor() {
        super("IRacingTools.Models.PositionF", [
            { no: 1, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<PositionF>): PositionF {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.x = 0;
        message.y = 0;
        if (value !== undefined)
            reflectionMergePartial<PositionF>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionF): PositionF {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float x */ 1:
                    message.x = reader.float();
                    break;
                case /* float y */ 2:
                    message.y = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionF, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Bit32).float(message.x);
        /* float y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Bit32).float(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message IRacingTools.Models.PositionF
 */
export const PositionF = new PositionF$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SizeI$Type extends MessageType<SizeI> {
    constructor() {
        super("IRacingTools.Models.SizeI", [
            { no: 1, name: "width", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "height", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SizeI>): SizeI {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.width = 0;
        message.height = 0;
        if (value !== undefined)
            reflectionMergePartial<SizeI>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SizeI): SizeI {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 width */ 1:
                    message.width = reader.uint32();
                    break;
                case /* uint32 height */ 2:
                    message.height = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SizeI, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 width = 1; */
        if (message.width !== 0)
            writer.tag(1, WireType.Varint).uint32(message.width);
        /* uint32 height = 2; */
        if (message.height !== 0)
            writer.tag(2, WireType.Varint).uint32(message.height);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message IRacingTools.Models.SizeI
 */
export const SizeI = new SizeI$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SizeF$Type extends MessageType<SizeF> {
    constructor() {
        super("IRacingTools.Models.SizeF", [
            { no: 1, name: "width", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "height", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<SizeF>): SizeF {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.width = 0;
        message.height = 0;
        if (value !== undefined)
            reflectionMergePartial<SizeF>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SizeF): SizeF {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float width */ 1:
                    message.width = reader.float();
                    break;
                case /* float height */ 2:
                    message.height = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SizeF, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float width = 1; */
        if (message.width !== 0)
            writer.tag(1, WireType.Bit32).float(message.width);
        /* float height = 2; */
        if (message.height !== 0)
            writer.tag(2, WireType.Bit32).float(message.height);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message IRacingTools.Models.SizeF
 */
export const SizeF = new SizeF$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RectI$Type extends MessageType<RectI> {
    constructor() {
        super("IRacingTools.Models.RectI", [
            { no: 1, name: "size", kind: "message", T: () => SizeI },
            { no: 2, name: "position", kind: "message", T: () => PositionI }
        ]);
    }
    create(value?: PartialMessage<RectI>): RectI {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RectI>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RectI): RectI {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* IRacingTools.Models.SizeI size */ 1:
                    message.size = SizeI.internalBinaryRead(reader, reader.uint32(), options, message.size);
                    break;
                case /* IRacingTools.Models.PositionI position */ 2:
                    message.position = PositionI.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RectI, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* IRacingTools.Models.SizeI size = 1; */
        if (message.size)
            SizeI.internalBinaryWrite(message.size, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* IRacingTools.Models.PositionI position = 2; */
        if (message.position)
            PositionI.internalBinaryWrite(message.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message IRacingTools.Models.RectI
 */
export const RectI = new RectI$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RectF$Type extends MessageType<RectF> {
    constructor() {
        super("IRacingTools.Models.RectF", [
            { no: 1, name: "size", kind: "message", T: () => SizeF },
            { no: 2, name: "position", kind: "message", T: () => PositionF }
        ]);
    }
    create(value?: PartialMessage<RectF>): RectF {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RectF>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RectF): RectF {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* IRacingTools.Models.SizeF size */ 1:
                    message.size = SizeF.internalBinaryRead(reader, reader.uint32(), options, message.size);
                    break;
                case /* IRacingTools.Models.PositionF position */ 2:
                    message.position = PositionF.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RectF, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* IRacingTools.Models.SizeF size = 1; */
        if (message.size)
            SizeF.internalBinaryWrite(message.size, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* IRacingTools.Models.PositionF position = 2; */
        if (message.position)
            PositionF.internalBinaryWrite(message.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message IRacingTools.Models.RectF
 */
export const RectF = new RectF$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VRPose$Type extends MessageType<VRPose> {
    constructor() {
        super("IRacingTools.Models.VRPose", [
            { no: 1, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "eyeY", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<VRPose>): VRPose {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.x = 0;
        message.eyeY = 0;
        message.z = 0;
        if (value !== undefined)
            reflectionMergePartial<VRPose>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VRPose): VRPose {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float x */ 1:
                    message.x = reader.float();
                    break;
                case /* float eyeY */ 2:
                    message.eyeY = reader.float();
                    break;
                case /* float z */ 3:
                    message.z = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VRPose, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Bit32).float(message.x);
        /* float eyeY = 2; */
        if (message.eyeY !== 0)
            writer.tag(2, WireType.Bit32).float(message.eyeY);
        /* float z = 3; */
        if (message.z !== 0)
            writer.tag(3, WireType.Bit32).float(message.z);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message IRacingTools.Models.VRPose
 */
export const VRPose = new VRPose$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VRLayout$Type extends MessageType<VRLayout> {
    constructor() {
        super("IRacingTools.Models.VRLayout", [
            { no: 1, name: "pose", kind: "message", T: () => VRPose },
            { no: 2, name: "size", kind: "message", T: () => SizeF }
        ]);
    }
    create(value?: PartialMessage<VRLayout>): VRLayout {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<VRLayout>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VRLayout): VRLayout {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* IRacingTools.Models.VRPose pose */ 1:
                    message.pose = VRPose.internalBinaryRead(reader, reader.uint32(), options, message.pose);
                    break;
                case /* IRacingTools.Models.SizeF size */ 2:
                    message.size = SizeF.internalBinaryRead(reader, reader.uint32(), options, message.size);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VRLayout, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* IRacingTools.Models.VRPose pose = 1; */
        if (message.pose)
            VRPose.internalBinaryWrite(message.pose, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* IRacingTools.Models.SizeF size = 2; */
        if (message.size)
            SizeF.internalBinaryWrite(message.size, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message IRacingTools.Models.VRLayout
 */
export const VRLayout = new VRLayout$Type();
