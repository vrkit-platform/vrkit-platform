// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "Session/SessionState.proto" (package "IRacingTools.Models.Session", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { FileInfo } from "../FileInfo";
import { TrackLayoutMetadata } from "../TrackLayoutMetadata";
/**
 * @generated from protobuf message IRacingTools.Models.Session.SessionTiming
 */
export interface SessionTiming {
    /**
     * @generated from protobuf field: bool is_live = 1;
     */
    isLive: boolean;
    /**
     * @generated from protobuf field: bool is_valid = 2;
     */
    isValid: boolean;
    /**
     * @generated from protobuf field: int32 sample_index = 50;
     */
    sampleIndex: number;
    /**
     * @generated from protobuf field: int32 sample_count = 51;
     */
    sampleCount: number;
    /**
     * @generated from protobuf field: int32 ticks = 60;
     */
    ticks: number;
    /**
     * @generated from protobuf field: int32 tick_count = 61;
     */
    tickCount: number;
    /**
     * @generated from protobuf field: int32 session_sub_count = 70;
     */
    sessionSubCount: number;
    /**
     * @generated from protobuf field: int32 session_sub_num = 71;
     */
    sessionSubNum: number;
    /**
     * @generated from protobuf field: IRacingTools.Models.Session.SessionSubType session_sub_type = 72;
     */
    sessionSubType: SessionSubType;
    /**
     * @generated from protobuf field: IRacingTools.Models.Session.SessionSubTimingType session_sub_timing_type = 73;
     */
    sessionSubTimingType: SessionSubTimingType;
    /**
     * @generated from protobuf field: int32 session_sub_lap = 75;
     */
    sessionSubLap: number;
    /**
     * @generated from protobuf field: int32 session_sub_lap_remaining = 76;
     */
    sessionSubLapRemaining: number;
    /**
     * @generated from protobuf field: int32 session_sub_lap_count = 77;
     */
    sessionSubLapCount: number;
    /**
     * @generated from protobuf field: int32 session_sub_time = 80;
     */
    sessionSubTime: number;
    /**
     * @generated from protobuf field: int32 session_sub_time_remaining = 81;
     */
    sessionSubTimeRemaining: number;
    /**
     * @generated from protobuf field: int32 session_sub_time_total = 82;
     */
    sessionSubTimeTotal: number;
}
/**
 * @generated from protobuf message IRacingTools.Models.Session.SessionData
 */
export interface SessionData {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: IRacingTools.Models.Session.SessionType type = 2;
     */
    type: SessionType;
    /**
     * @generated from protobuf field: IRacingTools.Models.Session.SessionStatus status = 5;
     */
    status: SessionStatus;
    /**
     * @generated from protobuf field: int32 sub_count = 6;
     */
    subCount: number;
    /**
     * @generated from protobuf field: int32 sub_id = 7;
     */
    subId: number;
    /**
     * @generated from protobuf field: int32 sub_num = 8;
     */
    subNum: number;
    /**
     * @generated from protobuf field: IRacingTools.Models.Session.SessionSubType sub_type = 9;
     */
    subType: SessionSubType;
    /**
     * @generated from protobuf field: IRacingTools.Models.Session.SessionTiming timing = 15;
     */
    timing?: SessionTiming;
    /**
     * @generated from protobuf field: IRacingTools.Models.TrackLayoutMetadata track_layout_metadata = 20;
     */
    trackLayoutMetadata?: TrackLayoutMetadata;
    /**
     * @generated from protobuf field: IRacingTools.Models.FileInfo file_info = 21;
     */
    fileInfo?: FileInfo;
    /**
     * @generated from protobuf field: IRacingTools.Models.Session.SessionCarStatus car_status = 30;
     */
    carStatus: SessionCarStatus;
    /**
     * @generated from protobuf field: string session_info_json = 90;
     */
    sessionInfoJson: string;
    /**
     * @generated from protobuf field: string session_info_yaml = 91;
     */
    sessionInfoYaml: string;
}
/**
 * Enum representing the sub-types of a session. This distinguishes
 * specific parts of a session, such as practice, qualifying, or race phases.
 *
 * @generated from protobuf enum IRacingTools.Models.Session.SessionSubType
 */
export enum SessionSubType {
    /**
     * @generated from protobuf enum value: SESSION_SUB_TYPE_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: SESSION_SUB_TYPE_PRACTICE = 1;
     */
    PRACTICE = 1,
    /**
     * @generated from protobuf enum value: SESSION_SUB_TYPE_QUALIFY = 2;
     */
    QUALIFY = 2,
    /**
     * @generated from protobuf enum value: SESSION_SUB_TYPE_RACE = 3;
     */
    RACE = 3
}
/**
 * @generated from protobuf enum IRacingTools.Models.Session.SessionSubTimingType
 */
export enum SessionSubTimingType {
    /**
     * @generated from protobuf enum value: SESSION_SUB_TIMING_TYPE_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: SESSION_SUB_TIMING_TYPE_TIMED = 1;
     */
    TIMED = 1,
    /**
     * @generated from protobuf enum value: SESSION_SUB_TIMING_TYPE_LAPS = 2;
     */
    LAPS = 2
}
/**
 * @generated from protobuf enum IRacingTools.Models.Session.SessionType
 */
export enum SessionType {
    /**
     * @generated from protobuf enum value: SESSION_TYPE_LIVE = 0;
     */
    LIVE = 0,
    /**
     * @generated from protobuf enum value: SESSION_TYPE_DISK = 1;
     */
    DISK = 1
}
/**
 * @generated from protobuf enum IRacingTools.Models.Session.SessionCarStatus
 */
export enum SessionCarStatus {
    /**
     * @generated from protobuf enum value: SESSION_CAR_STATUS_INVALID = 0;
     */
    INVALID = 0,
    /**
     * @generated from protobuf enum value: SESSION_CAR_STATUS_GET_IN_CAR = 1;
     */
    GET_IN_CAR = 1,
    /**
     * @generated from protobuf enum value: SESSION_CAR_STATUS_WARMUP = 3;
     */
    WARMUP = 3,
    /**
     * @generated from protobuf enum value: SESSION_CAR_STATUS_PARADE_LAPS = 4;
     */
    PARADE_LAPS = 4,
    /**
     * @generated from protobuf enum value: SESSION_CAR_STATUS_RACE = 5;
     */
    RACE = 5,
    /**
     * @generated from protobuf enum value: SESSION_CAR_STATUS_CHECKERED = 6;
     */
    CHECKERED = 6,
    /**
     * @generated from protobuf enum value: SESSION_CAR_STATUS_COOLDOWN = 7;
     */
    COOLDOWN = 7
}
/**
 * @generated from protobuf enum IRacingTools.Models.Session.SessionStatus
 */
export enum SessionStatus {
    /**
     * @generated from protobuf enum value: SESSION_STATUS_CREATED = 0;
     */
    CREATED = 0,
    /**
     * @generated from protobuf enum value: SESSION_STATUS_READY = 1;
     */
    READY = 1,
    /**
     * @generated from protobuf enum value: SESSION_STATUS_PAUSED = 2;
     */
    PAUSED = 2,
    /**
     * @generated from protobuf enum value: SESSION_STATUS_RUNNING = 5;
     */
    RUNNING = 5,
    /**
     * @generated from protobuf enum value: SESSION_STATUS_ERROR = 10;
     */
    ERROR = 10
}
// @generated message type with reflection information, may provide speed optimized methods
class SessionTiming$Type extends MessageType<SessionTiming> {
    constructor() {
        super("IRacingTools.Models.Session.SessionTiming", [
            { no: 1, name: "is_live", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "is_valid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 50, name: "sample_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 51, name: "sample_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 60, name: "ticks", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 61, name: "tick_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 70, name: "session_sub_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 71, name: "session_sub_num", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 72, name: "session_sub_type", kind: "enum", T: () => ["IRacingTools.Models.Session.SessionSubType", SessionSubType, "SESSION_SUB_TYPE_"] },
            { no: 73, name: "session_sub_timing_type", kind: "enum", T: () => ["IRacingTools.Models.Session.SessionSubTimingType", SessionSubTimingType, "SESSION_SUB_TIMING_TYPE_"] },
            { no: 75, name: "session_sub_lap", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 76, name: "session_sub_lap_remaining", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 77, name: "session_sub_lap_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 80, name: "session_sub_time", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 81, name: "session_sub_time_remaining", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 82, name: "session_sub_time_total", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SessionTiming>): SessionTiming {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isLive = false;
        message.isValid = false;
        message.sampleIndex = 0;
        message.sampleCount = 0;
        message.ticks = 0;
        message.tickCount = 0;
        message.sessionSubCount = 0;
        message.sessionSubNum = 0;
        message.sessionSubType = 0;
        message.sessionSubTimingType = 0;
        message.sessionSubLap = 0;
        message.sessionSubLapRemaining = 0;
        message.sessionSubLapCount = 0;
        message.sessionSubTime = 0;
        message.sessionSubTimeRemaining = 0;
        message.sessionSubTimeTotal = 0;
        if (value !== undefined)
            reflectionMergePartial<SessionTiming>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionTiming): SessionTiming {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_live */ 1:
                    message.isLive = reader.bool();
                    break;
                case /* bool is_valid */ 2:
                    message.isValid = reader.bool();
                    break;
                case /* int32 sample_index */ 50:
                    message.sampleIndex = reader.int32();
                    break;
                case /* int32 sample_count */ 51:
                    message.sampleCount = reader.int32();
                    break;
                case /* int32 ticks */ 60:
                    message.ticks = reader.int32();
                    break;
                case /* int32 tick_count */ 61:
                    message.tickCount = reader.int32();
                    break;
                case /* int32 session_sub_count */ 70:
                    message.sessionSubCount = reader.int32();
                    break;
                case /* int32 session_sub_num */ 71:
                    message.sessionSubNum = reader.int32();
                    break;
                case /* IRacingTools.Models.Session.SessionSubType session_sub_type */ 72:
                    message.sessionSubType = reader.int32();
                    break;
                case /* IRacingTools.Models.Session.SessionSubTimingType session_sub_timing_type */ 73:
                    message.sessionSubTimingType = reader.int32();
                    break;
                case /* int32 session_sub_lap */ 75:
                    message.sessionSubLap = reader.int32();
                    break;
                case /* int32 session_sub_lap_remaining */ 76:
                    message.sessionSubLapRemaining = reader.int32();
                    break;
                case /* int32 session_sub_lap_count */ 77:
                    message.sessionSubLapCount = reader.int32();
                    break;
                case /* int32 session_sub_time */ 80:
                    message.sessionSubTime = reader.int32();
                    break;
                case /* int32 session_sub_time_remaining */ 81:
                    message.sessionSubTimeRemaining = reader.int32();
                    break;
                case /* int32 session_sub_time_total */ 82:
                    message.sessionSubTimeTotal = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionTiming, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_live = 1; */
        if (message.isLive !== false)
            writer.tag(1, WireType.Varint).bool(message.isLive);
        /* bool is_valid = 2; */
        if (message.isValid !== false)
            writer.tag(2, WireType.Varint).bool(message.isValid);
        /* int32 sample_index = 50; */
        if (message.sampleIndex !== 0)
            writer.tag(50, WireType.Varint).int32(message.sampleIndex);
        /* int32 sample_count = 51; */
        if (message.sampleCount !== 0)
            writer.tag(51, WireType.Varint).int32(message.sampleCount);
        /* int32 ticks = 60; */
        if (message.ticks !== 0)
            writer.tag(60, WireType.Varint).int32(message.ticks);
        /* int32 tick_count = 61; */
        if (message.tickCount !== 0)
            writer.tag(61, WireType.Varint).int32(message.tickCount);
        /* int32 session_sub_count = 70; */
        if (message.sessionSubCount !== 0)
            writer.tag(70, WireType.Varint).int32(message.sessionSubCount);
        /* int32 session_sub_num = 71; */
        if (message.sessionSubNum !== 0)
            writer.tag(71, WireType.Varint).int32(message.sessionSubNum);
        /* IRacingTools.Models.Session.SessionSubType session_sub_type = 72; */
        if (message.sessionSubType !== 0)
            writer.tag(72, WireType.Varint).int32(message.sessionSubType);
        /* IRacingTools.Models.Session.SessionSubTimingType session_sub_timing_type = 73; */
        if (message.sessionSubTimingType !== 0)
            writer.tag(73, WireType.Varint).int32(message.sessionSubTimingType);
        /* int32 session_sub_lap = 75; */
        if (message.sessionSubLap !== 0)
            writer.tag(75, WireType.Varint).int32(message.sessionSubLap);
        /* int32 session_sub_lap_remaining = 76; */
        if (message.sessionSubLapRemaining !== 0)
            writer.tag(76, WireType.Varint).int32(message.sessionSubLapRemaining);
        /* int32 session_sub_lap_count = 77; */
        if (message.sessionSubLapCount !== 0)
            writer.tag(77, WireType.Varint).int32(message.sessionSubLapCount);
        /* int32 session_sub_time = 80; */
        if (message.sessionSubTime !== 0)
            writer.tag(80, WireType.Varint).int32(message.sessionSubTime);
        /* int32 session_sub_time_remaining = 81; */
        if (message.sessionSubTimeRemaining !== 0)
            writer.tag(81, WireType.Varint).int32(message.sessionSubTimeRemaining);
        /* int32 session_sub_time_total = 82; */
        if (message.sessionSubTimeTotal !== 0)
            writer.tag(82, WireType.Varint).int32(message.sessionSubTimeTotal);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message IRacingTools.Models.Session.SessionTiming
 */
export const SessionTiming = new SessionTiming$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionData$Type extends MessageType<SessionData> {
    constructor() {
        super("IRacingTools.Models.Session.SessionData", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["IRacingTools.Models.Session.SessionType", SessionType, "SESSION_TYPE_"] },
            { no: 5, name: "status", kind: "enum", T: () => ["IRacingTools.Models.Session.SessionStatus", SessionStatus, "SESSION_STATUS_"] },
            { no: 6, name: "sub_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "sub_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "sub_num", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "sub_type", kind: "enum", T: () => ["IRacingTools.Models.Session.SessionSubType", SessionSubType, "SESSION_SUB_TYPE_"] },
            { no: 15, name: "timing", kind: "message", T: () => SessionTiming },
            { no: 20, name: "track_layout_metadata", kind: "message", T: () => TrackLayoutMetadata },
            { no: 21, name: "file_info", kind: "message", T: () => FileInfo },
            { no: 30, name: "car_status", kind: "enum", T: () => ["IRacingTools.Models.Session.SessionCarStatus", SessionCarStatus, "SESSION_CAR_STATUS_"] },
            { no: 90, name: "session_info_json", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 91, name: "session_info_yaml", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SessionData>): SessionData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.type = 0;
        message.status = 0;
        message.subCount = 0;
        message.subId = 0;
        message.subNum = 0;
        message.subType = 0;
        message.carStatus = 0;
        message.sessionInfoJson = "";
        message.sessionInfoYaml = "";
        if (value !== undefined)
            reflectionMergePartial<SessionData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionData): SessionData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* IRacingTools.Models.Session.SessionType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* IRacingTools.Models.Session.SessionStatus status */ 5:
                    message.status = reader.int32();
                    break;
                case /* int32 sub_count */ 6:
                    message.subCount = reader.int32();
                    break;
                case /* int32 sub_id */ 7:
                    message.subId = reader.int32();
                    break;
                case /* int32 sub_num */ 8:
                    message.subNum = reader.int32();
                    break;
                case /* IRacingTools.Models.Session.SessionSubType sub_type */ 9:
                    message.subType = reader.int32();
                    break;
                case /* IRacingTools.Models.Session.SessionTiming timing */ 15:
                    message.timing = SessionTiming.internalBinaryRead(reader, reader.uint32(), options, message.timing);
                    break;
                case /* IRacingTools.Models.TrackLayoutMetadata track_layout_metadata */ 20:
                    message.trackLayoutMetadata = TrackLayoutMetadata.internalBinaryRead(reader, reader.uint32(), options, message.trackLayoutMetadata);
                    break;
                case /* IRacingTools.Models.FileInfo file_info */ 21:
                    message.fileInfo = FileInfo.internalBinaryRead(reader, reader.uint32(), options, message.fileInfo);
                    break;
                case /* IRacingTools.Models.Session.SessionCarStatus car_status */ 30:
                    message.carStatus = reader.int32();
                    break;
                case /* string session_info_json */ 90:
                    message.sessionInfoJson = reader.string();
                    break;
                case /* string session_info_yaml */ 91:
                    message.sessionInfoYaml = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* IRacingTools.Models.Session.SessionType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* IRacingTools.Models.Session.SessionStatus status = 5; */
        if (message.status !== 0)
            writer.tag(5, WireType.Varint).int32(message.status);
        /* int32 sub_count = 6; */
        if (message.subCount !== 0)
            writer.tag(6, WireType.Varint).int32(message.subCount);
        /* int32 sub_id = 7; */
        if (message.subId !== 0)
            writer.tag(7, WireType.Varint).int32(message.subId);
        /* int32 sub_num = 8; */
        if (message.subNum !== 0)
            writer.tag(8, WireType.Varint).int32(message.subNum);
        /* IRacingTools.Models.Session.SessionSubType sub_type = 9; */
        if (message.subType !== 0)
            writer.tag(9, WireType.Varint).int32(message.subType);
        /* IRacingTools.Models.Session.SessionTiming timing = 15; */
        if (message.timing)
            SessionTiming.internalBinaryWrite(message.timing, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* IRacingTools.Models.TrackLayoutMetadata track_layout_metadata = 20; */
        if (message.trackLayoutMetadata)
            TrackLayoutMetadata.internalBinaryWrite(message.trackLayoutMetadata, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* IRacingTools.Models.FileInfo file_info = 21; */
        if (message.fileInfo)
            FileInfo.internalBinaryWrite(message.fileInfo, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* IRacingTools.Models.Session.SessionCarStatus car_status = 30; */
        if (message.carStatus !== 0)
            writer.tag(30, WireType.Varint).int32(message.carStatus);
        /* string session_info_json = 90; */
        if (message.sessionInfoJson !== "")
            writer.tag(90, WireType.LengthDelimited).string(message.sessionInfoJson);
        /* string session_info_yaml = 91; */
        if (message.sessionInfoYaml !== "")
            writer.tag(91, WireType.LengthDelimited).string(message.sessionInfoYaml);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message IRacingTools.Models.Session.SessionData
 */
export const SessionData = new SessionData$Type();
